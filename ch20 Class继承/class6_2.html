<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>

<body>
    <script>
        //子类的静态方法中通过super调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例
        class A {
            constructor() {
                this.x = 1;
            }
            static print() {
                super.x = "aaaa"; // ！这里的super相当于 this，子类B调用时为B，基类A调用时为A;是静态方法，所以是类而不是类的实例
                console.log(super.x);// 这里的super 指向 __父类__，此处为3
                console.log(this.x); // 这里的this.x 和上一行的 super.x 输出不同，this和super并非同一个对象 ，this.x总是输出aaaa
            }
        }

        class B extends A {
            constructor() {
                super();
                this.x = 2;
            }
            static m() {
                super.print();
            }
        }

        A.__proto__.x = 3;
        B.m() // 3 aaaa 
        
        

        A.print();// 3 aaaa 
        // 静态方法中：指向父类 （super作为对象时，在普通方法中，指向**父类的原型对象**；在静态方法中，指向**父类**。）
        // 赋值： super.x赋值为3，这时等同于对this.x赋值为3。
        // 读取：而当读取super.x的时候，读的是A.prototype.x，所以返回3。
        // 赋值和读取时 super 指向分别为this 和 父类 

    </script>
</body>

</html>